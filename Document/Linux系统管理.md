# Linux系统管理

[TOC]

## Linux进程管理及作用

Linux 中虽然使用命令进行进程管理，但是进程管理的主要目的是一样的，即查看系统中运行的程序和进程、判断服务器的健康状态和强制中止不需要的进程。

### 什么是进程和程序

进程是**正在执行**的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。

**进程是正在执行中的程序。**当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。

httpd 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作**常驻内存进程**。

某些进程会产生一些新的进程，我们把这些进程称作**子进程**，而把这个进程本身称作**父进程**。

子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。

### 进程管理的作用

#### 判断服务器的健康状态

运维工程师最主要的工作就是保证服务器安全、稳定地运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。

进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。

#### 查看系统中所有的进程

查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务、是否有非法服务在运行。

#### 杀死进程

当需要停止服务时，会通过**正确关闭命令**来停止服务（如 apache 服务可以通过 service httpd stop 命令来关闭）。只有在正确终止进程的手段失效的情况下，才会考虑**使用 kill 命令**杀死进程。

## Linux进程启动的方式

在 Linux 系统中，每个进程都有一个唯一的进程号（PID），方便系统识别和调度进程。通过简单地输出运行程序的程序名，就可以运行该程序，其实也就是启动了一个进程。

启动一个进程主要有 2 种途径，分别是通过**手工启动**和**通过调度启动**（事先进行设置，根据用户要求，进程可以自行启动）。

### Linux手工启动进程

手工启动进程指的是**由用户输入命令直接启动一个进程**，根据所启动的进程类型和性质的不同，其又可以细分为**前台启动**和**后台启动** 2 种方式。

#### 前台启动进程

这是手工启动进程最常用的方式，因为当用户输入一个命令并运行，就已经启动了一个进程，而且是一个前台的进程，此时系统其实已经处于一个多进程的状态（一个是 Shell 进程，另一个是新启动的进程）。

#### 后台启动进程

从后台启动进程，其实就是**在命令结尾处添加一个 " &" 符号**（注意，& 前面有空格）。输入命令并运行之后，Shell 会提供给我们一个数字，此数字就是该进程的进程号。然后直接就会出现提示符，用户就可以继续完成其他工作。

共同特点：新进程都是由当前 Shell 这个进程产生的。Shell 创建了新进程，这种关系为进程间的父子关系，其中 Shell 是父进程，新进程是子进程。

一个父进程可以有多个子进程，通常子进程结束后才能继续父进程。当然，如果是从后台启动，父进程就不用等待子进程了。

### Linux调度启动进程

在 Linux 系统中，**任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。**

## ps命令：查看正在运行的进程

ps 命令是最常用的监控进程的命令，通过此命令可以查看系统中所有运行进程的详细信息。

**在不同的 Linux 发行版上，ps 命令的语法各不相同**，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps  命令的用户。

### ps 命令的基本格式

查看系统中所有的进程，使用 **BS 操作系统**格式：**ps aux**

查看系统中所有的进程，使用 **Linux 标准命令**格式：**ps -le**

选项：

- a：显示一个终端的**所有进程**，除会话引线外
- u：显示进程的**归属用户及内存的使用情况**
- x：显示**没有控制终端的进程**
- -l：**长格式**显示更加**详细**的信息
- -e：显示**所有进程**

**几个固定选项：**

- "**ps aux**" 可以查看系统中所有的进程
- "**ps -le**" 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级
- "**ps -l**" 只能看到当前 Shell 产生的进程

### ps aux 命令输出信息含义

| 表头    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| USER    | 该进程是由**哪个用户产生**的                                 |
| PID     | 进程的 ID                                                    |
| %CPU    | 该进程**占用 CPU 资源**的百分比，占用的百分比越高，进程越耗费资源 |
| %MEM    | 该进程**占用物理内存**的百分比，占用的百分比越高，进程越耗费资源 |
| VSZ     | 该进程**占用虚拟内存**的大小，单位为 **KB**                  |
| RSS     | 该进程**占用实际物理内存**的大小，单位为 **KB**              |
| TTY     | 该进程是**在哪个终端运行**的。其中，**tty1 ~ tty7 代表本地控制台终端**（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），**tty1~tty6 是本地的字符界面终端，tty7 是图形终端**。**pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端**，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。 |
| STAT    | 进程状态。常见的状态有以下几种：<br/>-D：不可被唤醒的**睡眠状态**，通常用于 I/O 情况<br/>-R：该进程**正在运行**<br/>-S：该进程处于**睡眠状态**，**可被唤醒**<br/>-T：**停止状态**，可能是在后台暂停或进程处于除错状态<br/>-W：**内存交互状态**（从 2.6 内核开始无效）<br/>-X：死掉的进程（应该不会出现）<br/>-Z：**僵尸进程**。进程已经中止，但是部分程序还在内存当中<br/>-<：高优先级（以下状态在 BSD 格式中出现）<br/>-N：低优先级<br/>-L：被锁入内存<br/>-s：**包含子进程**<br/>-l：**多线程**（小写 L）<br/>-+：位于后台 |
| START   | 该进程的**启动时间**                                         |
| TIME    | 该进程**占用 CPU 的运算时间**，注意不是系统时间              |
| COMMAND | **产生此进程的命令名**                                       |

### ps -le 命令输出信息含义

| 表头  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| F     | 进程标志，**说明进程的权限**，常见的标志有两个:<br/>1：进程可以被复制，但是不能被执行<br/>4：进程使用超级用户权限 |
| S     | **进程状态**。具体的状态和"**ps aux**"命令中的 **STAT** 状态一致 |
| UID   | 运行此进程的**用户的 ID**                                    |
| PID   | 进程的 ID                                                    |
| PPID  | 父进程的 ID                                                  |
| C     | 该进程的 **CPU 使用率**，单位是百分比                        |
| PRI   | 进程的**优先级**，数值越小，该进程的优先级越高，越早被 CPU 执行 |
| NI    | 进程的**优先级**，数值越小，该进程越早被执行                 |
| ADDR  | 该进程**在内存的哪个位置**                                   |
| SZ    | 该进程**占用多大内存**                                       |
| WCHAN | 该进程**是否运行**。**"-"代表正在运行**                      |
| TTY   | 该进程**由哪个终端产生**                                     |
| TIME  | 该进程**占用 CPU 的运算时间**，注意不是系统时间              |
| CMD   | **产生此进程的命令名**                                       |

关于僵尸进程：

僵尸进程的产生一般是由于进程非正常停止或程序编写错误，导致**子进程先于父进程结束**，**而父进程又没有正确地回收子进程**，从而造成**子进程一直存在于内存当中**，这就是僵尸进程。

僵尸进程会对主机的稳定性产生影响，所以，在产生僵尸进程后，一定要对产生僵尸进程的软件进行优化，避免一直产生僵尸进程；对于已经产生的僵尸进程，可以在查找出来之后强制中止。

## top命令：持续监听进程运行状态

top 命令可以**动态地持续监听进程地运行状态**，与此同时，该命令还提供了一个**交互界面**，用户可以根据需要，人性化地定制自己的输出，进而更清楚地了进程的运行状态。

**top 命令的基本格式：top [选项]**

### top命令选项和交互操作

选项：

- -d 秒数：指定 top 命令**每隔几秒更新**。默认是 3 秒
- -b：使用**批处理模式输出**。一般和 "-n" 选项合用，用于**把 top 命令重定向到文件中**
- -n 次数：指定 top 命令**执行的次数**。一般和 "-b" 选项合用
- -p 进程PID：仅查看**指定 ID 的进程**
- -s：使 top 命令在**安全模式中运行**，避免在交互模式中出现错误
- -u 用户名：只**监听某个用户的进程**

在 top 命令的显示窗口中，还可以使用如下按键，进行一下**交互操作**：

- ? 或 h：显示交互模式的**帮助**
- P：按照 **CPU 的使用率排序**，默认就是此选项
- M：按照**内存的使用率排序**
- N：按照 **PID 排序**
- T：按照 **CPU 的累积运算时间排序**，也就是按照 TIME+ 项排序
- k：按照 PID **给予某个进程一个信号**。一般用于中止某个进程，信号 9 是强制中止的信号
- r：按照 PID **给某个进程重设优先级（Nice）值**
- q：**退出** top 命令

### top 命令的输出

top 命令的输出内容是**动态的**，默认每隔 3 秒刷新一次。命令的输出主要分为两部分：

1. 第一部分是前五行，显示的是**整个系统的资源使用状况**，我们就是通过这些输出来判断服务器的资源使用状态的
2. 第二部分从第六行开始，显示的是**系统中进程的信息**

#### top 命令的第一部分输出

第一部分的作用：

- 第一行为任务队列信息，任务队列信息如下：

| 内 容                         | 说 明                                                        |
| ----------------------------- | ------------------------------------------------------------ |
| 12:26:46                      | 系统**当前时间**                                             |
| up 1 day, 13:32               | 系统的**运行时间**.本机己经运行 1 天 13 小时 32 分钟         |
| 2 users                       | 当前登录了两个用户                                           |
| load average: 0.00,0.00，0.00 | 系统**在之前 1 分钟、5 分钟、15 分钟的平均负载**。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数） |

- 第二行为进程信息，进程信息如下：

| 内 容           | 说 明                                              |
| --------------- | -------------------------------------------------- |
| Tasks: 95 total | 系统中的**进程总数**                               |
| 1 running       | **正在运行**的进程数                               |
| 94 sleeping     | **睡眠**的进程数                                   |
| 0 stopped       | **正在停止**的进程数                               |
| 0 zombie        | **僵尸进程数**。如果不是 0，则需要手工检查僵尸进程 |

- 第三行为 CPU 信息，CPU信息如下：

| 内 容           | 说 明                                                        |
| --------------- | ------------------------------------------------------------ |
| Cpu(s): 0.1 %us | **用户模式**占用的 CPU 百分比                                |
| 0.1%sy          | **系统模式**占用的 CPU 百分比                                |
| 0.0%ni          | **改变过优先级的用户进程**占用的 CPU 百分比                  |
| 99.7%id         | **空闲 CPU** 占用的 CPU 百分比                               |
| 0.1%wa          | **等待输入/输出的进程**占用的 CPU 百分比                     |
| 0.0%hi          | **硬中断请求服务**占用的 CPU 百分比                          |
| 0.1%si          | **软中断请求服务**占用的 CPU 百分比                          |
| 0.0%st          | st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比 |

- 第四行为物理内存信息，物理内存信息如下：

| 内 容              | 说 明                        |
| ------------------ | ---------------------------- |
| Mem: 625344k total | **物理内存的总量**，单位为KB |
| 571504k used       | **己经使用**的物理内存数量   |
| 53840k&ee          | **空闲**的物理内存数量       |
| 65800k buffers     | **作为缓冲**的内存数量       |

- 第五行为交换分区（swap）信息，交换分区信息如下：

| 内 容               | 说 明                            |
| ------------------- | -------------------------------- |
| Swap: 524280k total | 交换分区（虚拟内存）的**总大小** |
| Ok used             | **已经使用**的交换分区的大小     |
| 524280k free        | **空闲**交换分区的大小           |
| 409280k cached      | **作为缓存**的交换分区的大小     |

通过 top 命令的第一部分就可以判断服务器的健康状态。

**缓冲（buffer）和缓存（cache）的区别：**

- 缓存（cache）是在读取硬盘中的数据时，把最常用的数据**保存在内存的缓存区中**，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。
- 缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。

**缓存（cache）是用来加速数据从硬盘中"读取"的，而缓冲（buffer）是用来加速数据"写入"硬盘的。**

#### top 命令的第二部分输出

主要是系统进程信息，各个字段的含义如下：

- PID：进程的 ID
- USER：该进程所属的用户
- PR：**优先级**，数值越小，优先级越高
- NI：**优先级**，数值越小，优先级越高
- VIRT：该进程使用的**虚拟内存**的大小，单位为 KB
- RES：该进程使用的**物理内存**的大小，单位为 KB
- SHR：**共享内存大小**，单位为 KB
- S：**进程状态**
- %CPU：该进程**占用 CPU** 的百分比
- %MEM：该进程**占用内存**的百分比
- TIME+：该进程**共占用的 CPU 时间**
- COMMAND：进程的**命令名**

这部分和 **ps 命令的输出**比较类似，只是如果在终端执行 top 命令，则不能看到所有的进程，而只能看到**占比靠前的进程**。

## pstree命令：查看进程树

pstree 命令是以**树形结构**显示程序和进程之间的关系。

**基本格式：pstree [选项] [PID或用户名]**

pstree命令常用选项及含义：

| 选项 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示启动每个进程对应的**完整指令**，包括启动进程的路径、参数等 |
| -c   | 不使用精简法显示进程信息，即显示的进程中**包含子进程和父进程** |
| -n   | 根据进程 PID 号来**排序输出**，默认是以程序名排序输出的      |
| -p   | 显示进程的 PID                                               |
| -u   | 显示进程对应的**用户名称**                                   |

在使用 pstree 命令时，如果不指定进程的 PID 号，也不指定用户名称，则会**以 init 进程为根进程**，**显示系统中所有程序和进程的信息**。反之，若指定 PID 号或用户名，则将以 PID 或指定命令为根进程，显示 PID 或用户对应的所有程序和进程。

init 进程是系统启动的第一个进程，进程的 PID 是 1，也是系统中所有进程的父进程。

## lsof命令：列出进程调用或打开的文件信息

lsof 命令，**“list opened files”**的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。

**基本格式：lsof [选项]**

lsof 命令常用选项及功能：

| 选项      | 功能                                   |
| --------- | -------------------------------------- |
| -c 字符串 | 只列出**以字符串开头的进程**打开的文件 |
| +d 目录名 | 列出**某个目录中**所有被进程调用的文件 |
| -u 用户名 | 只列出**某个用户的进程**打开的文件     |
| -p pid    | 列出**某个 PID 进程**打开的文件        |

## Linux进程优先级

Linux 是一个多用户、多任务的操作系统，系统中通常运行着非常多的进程。但是 CPU 在一个时钟周期内只能运算一条指令（现在的 CPU 采用了多线程、多核心技术，所以在一个时钟周期内可以运算多条指令。 但是同时运算的指令数也远远小于系统中的进程总数）。

在 Linux 系统中，表示进程优先级的有两个参数：**Priority** 和 **Nice**。

其中，PRI 代表 Priority，NI 代表 Nice。这两个值都表示优先级，数值越小代表该进程越优先被 CPU 处理。不过，**PRI值是由内核动态调整的，用户不能直接修改**。所以我们只能**通过修改 NI 值来影响 PRI 值，间接地调整进程优先级**。

PRI 和 NI 的关系：PRI (最终值) = PRI (原始值) + NI

NI 值越小，进程的 PRI 就会降低，该进程就越优先被 CPU 处理，反之，NI 值越大，进程的 PRI 值就会増加，该进程就越靠后被 CPU 处理。

修改 NI 值时有几个注意事项：

- NI 范围是 -20~19
- 普通用户调整 NI 值的范围是 0~19，而且只能调整自己的进程
- 普通用户**只能调高 NI 值**，而不能降低。如原本 NI 值为 0，则只能调整为大于 0
- 只有 root 用户才能设定进程 NI 值为负值，而且可以调整任何用户的进程

## nice和renice命令：改变进程优先级

当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程优先级的值（也称为 nice 值）。每个进程都有一个介于 -20 到 19 之间的 nice 值。默认情况下，进程的 nice 值为 0。

进程的 nice 值，可以通过 nice 命令和 renice 命令修改，进而调整进程的运行顺序。

### nice命令

nice 命令可以**给要启动的进程赋予 NI 值**，但是不能修改已运行进程的 NI 值。

**nice 命令格式：nice [-n NI值] 命令**

-n NI值：给命令赋予 NI 值，该值的范围为 -20~19

### renice 命令

同 nice 命令恰恰相反，renice 命令可以**在进程运行时修改其 NI 值**，从而调整优先级。

**renice 命令格式：renice [优先级] PID**

注意：此命令中使用的是进程的 PID 号，因此**常与 ps 等命令配合使用**。

## Linux常用信号（进程间通信）及其含义

进程的管理主要是指进程的关闭与重启。我们一般关闭或重启软件，都是关闭或重启它的程序，而不是直接操作进程的。

系统中可以识别的信号较多，我们可以**使用命令"kill -l"或"man 7 signal"来查询**。

常见的进程信号：

| 信号代号 | 信号名称 | 说 明                                                        |
| -------- | -------- | ------------------------------------------------------------ |
| 1        | SIGHUP   | 该信号让进程立即关闭.然后重新读取配置文件之后重启            |
| 2        | SIGINT   | 程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键     |
| 8        | SIGFPE   | 在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误 |
| 9        | SIGKILL  | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |
| 14       | SIGALRM  | 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号 |
| 15       | SIGTERM  | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |
| 18       | SIGCONT  | 该信号可以让暂停的进程恢复执行。本信号不能被阻断             |
| 19       | SIGSTOP  | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |

## kill命令：终止进程

从本质上讲，kill 命令只是用来向进程发送一个信号，至于这个信号是什么，是用户指定的。

kill 命令会**向操作系统内核发送一个信号**（多是终止信号）和**目标进程的 PID**，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。

**基本格式：kill [信号] PID**

kill 命令是按照 PID 来确定进程的，所以 kill 命令只能识别 PID，而不能识别进程名。Linux 定义了几十种不同类型的信号，可以使用 kill -l 命令查看所有信号及其编号。

kill命令常用信号及其含义：

| 信号编号 | 信号名 | 含义                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 0        | EXIT   | 程序退出时收到该信息                                         |
| 1        | HUP    | 挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化 |
| 2        | INT    | 表示结束进程，但并不是强制性的，常用的 "Ctrl+C" 组合键发出就是一个 kill -2 的信号 |
| 3        | QUIT   | 退出                                                         |
| 9        | KILL   | 杀死进程，即强制结束进程                                     |
| 11       | SEGV   | 段错误                                                       |
| 15       | TERM   | 正常结束进程，是 kill 命令的默认信号                         |

kill 命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。

## killall命令：终止特定的一类进程

killall 也是用于关闭进程的一个命令，但和 kill 不同的是，killall 命令不再依靠 PID 来杀死单个进程，而是**通过程序的进程名来杀死一类进程**，也正是由于这一点，该命令常与 ps、pstree 等命令配合使用。

**基本格式：killall [选项] [信号] 进程名**

注意，此命令的信号类型**同 kill 命令一样**，此命令常用的选项有如下 2 个：

- -i：交互式，询问是否要杀死某个进程
- -I：忽略进程名的大小写

## pkill命令：终止进程，按终端号踢出用户

当作于管理进程时，pkill 命令和 killall 命令的用法相同，都是**通过进程名杀死一类进程**。

**基本格式：pkill [信号] 进程名**

pkill 命令常用信号及其含义：

| 信号编号 | 信号名 | 含义                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 0        | EXIT   | 程序退出时收到该信息                                         |
| 1        | HUP    | 挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化 |
| 2        | INT    | 表示结束进程，但并不是强制性的，常用的 "Ctrl+C" 组合键发出就是一个 kill -2 的信号 |
| 3        | QUIT   | 退出                                                         |
| 9        | KILL   | 杀死进程，即强制结束进程                                     |
| 11       | SEGV   | 段错误                                                       |
| 15       | TERM   | 正常结束进程，是 kill 命令的默认信号                         |

### pkill命令踢出登陆用户

按照终端号来踢出用户登录。

**基本格式：pkill [-t 终端号] 进程名**

[-t 终端号] 选项用于按照终端号踢出用户

## Linux工作管理简介

工作管理指的是在单个登录终端（也就是登录的 Shell 界面）同时管理多个工作的行为。

把命令放入后台，然后把命令恢复到前台，或者让命令恢复到后台执行，这些管理操作就是工作管理。

后台管理注意事项：

1. 前台是指当前可以操控和执行命令的这个操作环境；后台是指工作可以自行运行，但是不能直接用 Ctrl+C 快捷键来中止它，只能使用 fg/bg 来调用工作。
2. 当前的登录终端只能管理当前终端的工作，而不能管理其他登录终端的工作。比如 tty1 登录的终端是不能管理 tty2 终端中的工作的。
3. 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作它。
4. 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则只能放入后台暂停，而不能执行。比如 vi 命令只能放入后台暂停，而不能执行，因为 vi 命令需要前台输入信息；top 命令也不能放入后台执行，而只能放入后台暂停，因为 top 命令需要和前台交互。

## Linux命令放入后台运行方法（&和Ctrl+Z）

### "命令 &"把命令放入后台执行

第一种把命令放入后台的方法是在命令后面加入空格 &。使用这种方法放入后台的命令，在后台处于执行状态。

注意：放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。

### 命令执行过裎中按 Ctrl+Z 快捷键，命令在后台处于暂停状态

使用这种方法放入后台的命令，就算不和前台有交互，能在后台执行，也处于暂停状态，因为 Ctrl+Z 快捷键就是暂停的快捷键。

每个被放入后台的命令都会被分配一个工作号。第一个被放入后台的命令，工作号是 1；第二个被放入后台的命令，工作号是 2，以此类推。

## jobs命令：查看当前终端放入后台的工作

jobs 命令可以用来查看当前终端放入后台的工作，工作管理的名字也来源于 jobs 命令。

**基本格式：jobs [选项]**

jobs 命令常用选项及含义：

| 选项           | 含义                                 |
| -------------- | ------------------------------------ |
| -l（L 的小写） | 列出进程的 PID 号                    |
| -n             | 只列出上次发出通知后改变了状态的进程 |
| -p             | 只列出进程的 PID 号                  |
| -r             | 只列出运行中的进程                   |
| -s             | 只列出已停止的进程                   |

"+"号代表最近一个放入后台的工作，也是工作恢复时默认恢复的工作。"-"号代表倒数第二个放入后台的工作，而第三个以后的工作就没有"+-"标志了。

一旦当前的默认工作处理完成，则带减号的工作就会自动成为新的默认工作，换句话说，不管此时有多少正在运行的工作，任何时间都会有且仅有一个带加号的工作和一个带减号的工作。

## fg命令：把后台命令恢复在前台执行

fg 命令用于把后台工作恢复到前台执行。

**基本格式：fg %工作号**

注意：在使用此命令时，％ 可以省略，但若将% 工作号全部省略，则此命令会将带有 + 号的工作恢复到前台。另外，使用此命令的过程中， % 可有可无。

## bg命令：把后台暂停的工作恢复到后台执行

**基本格式：bg ％工作号**

和 fg 命令类似，这里的 % 可以省略。

## nohup命令：后台命令脱离终端运行

前面一直在说进程可以放到后台运行，这里的后台指的是当前登陆终端的后台。

这种情况下，当我们以远程管理服务器的方式，在远程终端执行后台命令，如果在命令尚未执行完毕时就退出登陆，那么这个后台命令不会继续执行，此命令的执行会被中断。

如果我们确实需要**在远程终端执行某些后台命令**，该如何执行呢？有以下 3 种方法：

1. 把需要在后台执行的命令**加入 /etc/rc.local 文件**，让系统在**启动时执行这个后台程序**。这种方法的问题是，服务器是不能随便重启的，如果有临时后台任务，就不能执行了。
2. 使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。
3. 使用 nohup 命令。

nohup 命令的作用就是**让后台工作在离开操作终端时，也能够正确地在后台执行**。

**基本格式：nohup [命令] &**

注意：这里的‘&’表示此命令会在终端后台工作；反之，如果没有‘&’，则表示此命令会在终端前台工作。

## vmstat命令：监控系统资源

vmstat命令，是 **Virtual Meomory Statistics（虚拟内存统计）**的缩写，可用来监控 CPU 使用、进程状态、内存使用、虚拟内存使用、硬盘输入/输出状态等信息。此命令的基本格式有如下 2 种：

- **vmstat [-a] [刷新延时 刷新次数]**
- **vmstat [选项]** 

-a 的含义是用 inact/active（活跃与否） 来取代 buff/cache 的内存输出信息。

vmstat命令常用选项及含义：

| 选项              | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -fs               | -f：显示**从启动到目前为止**，系统**复制（fork）的程序数**，此信息是从 /proc/stat 中的 processes 字段中取得的<br/>-s：将**从启动到目前为止**，由一些事件导致的**内存变化情况**列表说明。 |
| -S 单位           | 令输出的数据**显示单位**，例如用 K/M 取代 bytes 的容量       |
| -d                | 列出**硬盘有关读写总量**的统计表                             |
| -p 分区设备文件名 | 查看**硬盘分区的读写情况**                                   |

vmstat 命令输出字段及含义：

| 字段   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| procs  | 进程信息字段：<br/>-r：等待运行的进程数，数量越大，系统越繁忙<br/>-b：不可被唤醒的进程数量，数量越大，系统越繁忙 |
| memory | 内存信息字段：<br/>-swpd：虚拟内存的使用情况，单位为 KB<br/>-free：空闲的内存容量，单位为 KB<br/>-buff：缓冲的内存容量，单位为 KB<br/>-cache：缓存的内存容量，单位为 KB |
| swap   | 交换分区信息字段：<br/>-si：从磁盘中交换到内存中数据的数量，单位为 KB<br/>-so：从内存中交换到磁盘中数据的数量，单位为 KB<br/>这两个数越大，表明数据需要经常在磁盘和内存之间进行交换，系统性能越差 |
| io     | 磁盘读/写信息字段：<br/>-bi：从块设备中读入的数据的总量，单位是块<br/>-bo：写到块设备的数据的总量，单位是块<br/>这两个数越大，代表系统的 I/O 越繁忙 |
| system | 系统信息字段：<br/>-in：每秒被中断的进程次数<br/>-cs：每秒进行的事件切换次数<br/>这两个数越大，代表系统与接口设备的通信越繁忙 |
| cpu    | CPU信息字段：<br/>-us：非内核进程消耗 CPU 运算时间的百分比<br/>-sy：内核进程消耗 CPU 运算时间的百分比<br/>-id：空闲 CPU 的百分比<br/>-wa：等待 I/O 所消耗的 CPU 百分比<br/>-st：被虚拟机所盗用的 CPU 百分比 |

## dmesg命令：显示开机信息

无论是系统启动过程中，还是系统运行过程中，只要是内核产生的信息，都会被**存储在系统缓冲区中**，如果开机时来不及查看相关信息，可以使用 dmesg 命令将信息调出，此命令常用于查看系统的硬件信息。

除此之外，开机信息也可以**通过 /var/log/ 目录中的 dmesg 文件进行查看**。

**基本格式：dmesg**

## free命令：查看内存使用状态

free 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 top 命令的内存部分非常相似。

**基本格式：free [选项]**

free 命令常用选项及含义：

| 选项        | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| -b          | 以 Byte（字节）为单位，显示内存使用情况                      |
| -k          | 以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项 |
| -m          | 以 MB 为单位，显示内存使用情况                               |
| -g          | 以 GB 为单位，显示内存使用情况                               |
| -t          | 在输出的最终结果中，输出内存和 swap 分区的总量               |
| -o          | 不显示系统缓冲区这一列                                       |
| -s 间隔秒数 | 根据指定的间隔时间，**持续显示**内存使用情况                 |

第一行显示的是各个列的列表头信息，各自的含义如下所示：

- total 是总内存数
- used 是已经使用的内存数
- free 是空闲的内存数
- shared 是多个进程共享的内存总数
- buffers 是缓冲内存数
- cached 是缓存内存数

Mem 一行指的是内存的使用情况；-/buffers/cache 的内存数，相当于第一行的 used-buffers-cached。+/buffers/cache 的内存数，相当于第一行的 free+buffers+cached；Swap 一行指的就是 swap 分区的使用情况。

## w和who命令：查看登陆用户信息

Linux 中，使用 w 或 who 命令都可以查看服务器上目前已登录的用户信息，两者的区别在于，w 命令除了能知道目前已登陆的用户信息，还可以知道每个用户执行任务的情况。

### w 命令

**基本格式：w [选项] [用户名]**

如果 w 命令后跟 [用户名]，则表示只显示此用户的信息。

w 命令的选项及含义：

| 选项 | 含义                                            |
| ---- | ----------------------------------------------- |
| -h   | 不显示输出信息的标题                            |
| -l   | 用长格式输出                                    |
| -s   | 用短格式输出，不显示登陆时间，JCPU 和 PCPU 时间 |
| -V   | 显示版本信息                                    |

输出信息中，第一行其实和 top 命令的第一行非常类似，主要显示了当前的系统时间、系统从启动至今已运行的时间、登陆到系统中的用户数和系统平均负载。

平均负载（load average）指的是在 1 分钟、5 分钟、15 分钟内系统的负载状况。

从第二行开始，显示的是当前所有登陆系统的用户信息，第二行是用户信息的各列标题，从第三行开始每行代表一个用户。

w 命令输出信息各列标题及含义：

| 标题   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| USER   | 登录到系统的用户                                             |
| TTY    | 登录终端                                                     |
| FROM   | 表示用户从哪里登陆进来，一般显示远程登陆主机的 IP 地址或者主机名 |
| LOGIN@ | 用户登陆的日期和时间                                         |
| IDLE   | 表示某个程序上次从终端开始执行到现在所持续的时间             |
| JCPU   | 和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间 |
| PCPU   | 当前进程所占用的 CPU 运算时间                                |
| WHAT   | 当前用户正在执行的进程名称和选项，换句话说，就是表示用户当前执行的是什么命令 |

### who 命令

相比较 w 命令，who 命令只能显示当前登陆的用户信息，但无法知晓每个用户正在执行的命令。

**基本格式：who [选项] [file]**

who 命令默认是通过 /var/run/utmp 文件来获取登陆用户信息，但如果通过 file 指定另一个文件，则 who 命令将不再默认读取 /var/run/utmp 文件，而是读取该指定文件来获取信息。

who 命令常用选项及含义：

| 选项     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| -a       | 列出所有信息，相当于所有选项                                 |
| -b       | 列出系统最近启动的时间日期                                   |
| -l       | 列出所有可登陆的终端信息                                     |
| -m       | 仅列出关于当前终端的信息，who -m 命令等同于 who am i         |
| -q       | 列出在本地系统上的用户和用户数的清单                         |
| -r       | 显示当前系统的运行级别                                       |
| -s       | 仅显示名称、线路和时间字段信息，这是 who 命令的默认选项      |
| -u       | 显示当前每个用户的用户名、登陆终端、登陆时间、线路活动和进程标识 |
| -T 或 -w | 显示 tty 终端的状态，“+”表示对任何人可写，“-”表示仅对 root 用户或所有者可写，“？”表示遇到线路故障 |

## last和lastlog命令：查看过去登陆的用户信息

last 命令可以查看当前和过去登陆系统用户的相关信息；lastlog 命令可以查看到每个系统用户最近一次登陆系统的时间。

**基本格式：last [选项]**

last 命令常用选项及含义：

| 选项        | 含义                                             |
| ----------- | ------------------------------------------------ |
| -a          | 把从何处登陆系统的主机名或 IP 地址显示在最后一行 |
| -R          | 不显示登陆系统的主机名或 IP 地址                 |
| -x          | 显示系统关机、重新开机以及执行等级的改变等信息   |
| -n 显示列数 | 设置列出信息的显示列数                           |
| -d          | 将显示的 IP 地址转换成主机名称                   |

在执行 last 命令时，它默认会读取 /var/log/wtmp 日志文件，这是一个二进制文件，不能直接用 vi 编辑，只能通过 last 命令调用。

lastlog 命令可以查看登陆过当前系统用户的最近一次登陆时间。

lastlog 命令默认是去读取 /var/log/lastlog 日志文件的，这个文件同样是二进制文件，不能直接用 vi 编辑，需要使用 lastlog 命令调用。



